<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Purrsuit</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Nunito:wght@400;700&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { overflow: hidden; background: #1a1a2e; font-family: 'Nunito', sans-serif; touch-action: none; -webkit-user-select: none; user-select: none; }
  canvas { display: block; touch-action: none; }

  #blocker { position: fixed; inset: 0; z-index: 100; background: rgba(20,15,10,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: opacity 0.3s; }
  #blocker.hidden { opacity: 0; pointer-events: none; }
  #blocker h1 { font-family: 'Fredoka', sans-serif; font-size: 4rem; color: #F7C948; text-shadow: 3px 3px 0 #D4730F; margin-bottom: 0.5rem; letter-spacing: 2px; }
  #blocker .subtitle { color: #E8C9A0; font-size: 1.2rem; margin-bottom: 2rem; text-align: center; padding: 0 20px; }
  #blocker .prompt { color: #fff; font-size: 1.4rem; padding: 12px 32px; border-radius: 50px; background: #E8822A; font-family: 'Fredoka', sans-serif; animation: pulse 2s ease-in-out infinite; }
  @media (max-width: 600px) { #blocker h1 { font-size: 2.8rem; } #blocker .subtitle { font-size: 1rem; } #blocker .prompt { font-size: 1.1rem; padding: 10px 24px; } }
  @keyframes pulse { 0%,100%{transform:scale(1);} 50%{transform:scale(1.05);} }

  #hud { position: fixed; inset: 0; z-index: 10; pointer-events: none; display: none; }
  #hud.active { display: block; }
  .hud-top { display: flex; justify-content: space-between; align-items: center; padding: 16px 24px; color: #fff; font-family: 'Fredoka', sans-serif; }
  .hud-day { font-size: 1.3rem; color: #F7C948; }
  .hud-timer { font-size: 2rem; color: #fff; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
  .hud-timer.urgent { color: #FF4444; animation: timerPulse 0.5s ease-in-out infinite; }
  @keyframes timerPulse { 0%,100%{transform:scale(1);} 50%{transform:scale(1.15);} }
  .hud-score { font-size: 1.3rem; color: #F7C948; }
  .hud-ring { font-size: 0.9rem; color: #B8956A; }
  @media (max-width: 600px) { .hud-top { padding: 10px 14px; } .hud-day,.hud-score { font-size: 1rem; } .hud-timer { font-size: 1.5rem; } }

  .hud-bottom-center { position: absolute; bottom: 24px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; align-items: center; }
  .hud-bag { background: rgba(0,0,0,0.5); border-radius: 12px; padding: 8px 20px; color: #fff; font-size: 1.1rem; font-family: 'Fredoka', sans-serif; border: 2px solid rgba(255,255,255,0.2); }
  .hud-bag.full { border-color: #FF6B35; color: #FF6B35; }
  @media (max-width: 600px) { .hud-bottom-center { bottom: 130px; } .hud-bag { font-size: 0.9rem; padding: 6px 14px; } }

  .hud-center-msg { position: absolute; top: 55%; left: 50%; transform: translate(-50%,-50%); color: #F7C948; font-family: 'Fredoka', sans-serif; font-size: 1.4rem; text-align: center; text-shadow: 2px 2px 4px rgba(0,0,0,0.7); opacity: 0; transition: opacity 0.3s; padding: 0 20px; }
  .hud-center-msg.visible { opacity: 1; }
  @media (max-width: 600px) { .hud-center-msg { font-size: 1.1rem; top: 50%; } }

  .crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); width: 24px; height: 24px; opacity: 0.6; }
  .crosshair::before,.crosshair::after { content: ''; position: absolute; background: #fff; }
  .crosshair::before { width: 2px; height: 100%; left: 50%; transform: translateX(-50%); }
  .crosshair::after { width: 100%; height: 2px; top: 50%; transform: translateY(-50%); }

  .catch-flash { position: absolute; top: 40%; left: 50%; transform: translate(-50%,-50%); color: #4ADE80; font-family: 'Fredoka', sans-serif; font-size: 2rem; font-weight: 700; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); opacity: 0; pointer-events: none; }
  .catch-flash.show { animation: catchFlash 0.8s ease-out forwards; }
  @keyframes catchFlash { 0%{opacity:1;transform:translate(-50%,-50%) scale(0.5);} 30%{opacity:1;transform:translate(-50%,-50%) scale(1.2);} 100%{opacity:0;transform:translate(-50%,-70%) scale(1);} }

  .expand-flash { position: absolute; top: 45%; left: 50%; transform: translate(-50%,-50%); color: #FFD700; font-family: 'Fredoka', sans-serif; font-size: 2.2rem; font-weight: 700; text-shadow: 3px 3px 6px rgba(0,0,0,0.7); opacity: 0; pointer-events: none; text-align: center; }
  .expand-flash.show { animation: expandFlash 3s ease-out forwards; }
  @keyframes expandFlash { 0%{opacity:0;transform:translate(-50%,-50%) scale(0.3);} 10%{opacity:1;transform:translate(-50%,-50%) scale(1.1);} 25%{opacity:1;transform:translate(-50%,-50%) scale(1);} 80%{opacity:1;} 100%{opacity:0;} }

  .settings-panel { margin-top: 24px; background: rgba(255,255,255,0.08); border-radius: 14px; padding: 16px 22px; width: 100%; max-width: 320px; display: none; }
  .settings-panel.visible { display: block; }
  .settings-title { font-family: 'Fredoka', sans-serif; font-size: 1.1rem; color: #F7C948; margin-bottom: 12px; text-align: center; }
  .setting-row { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; color: #E8C9A0; font-size: 0.9rem; }
  .setting-label { flex: 1; min-width: 100px; }
  .setting-row input[type="range"] { flex: 1.2; accent-color: #E8822A; height: 6px; cursor: pointer; }
  .setting-value { min-width: 36px; text-align: right; font-family: 'Fredoka', sans-serif; color: #F7C948; font-size: 0.95rem; }
  .hud-pause { display: none; font-size: 1.5rem; pointer-events: auto; cursor: pointer; padding: 4px 8px; opacity: 0.7; -webkit-tap-highlight-color: transparent; }
  @media (max-width: 600px) { .hud-pause { display: block; } }

  #mobile-controls { display: none; position: fixed; inset: 0; z-index: 15; pointer-events: none; }
  #mobile-controls.active { display: block; }
  .joystick-zone { position: absolute; bottom: 0; left: 0; width: 45%; height: 50%; pointer-events: auto; touch-action: none; }
  .joystick-base { position: absolute; width: 140px; height: 140px; bottom: 20px; left: 20px; border-radius: 50%; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); transition: opacity 0.15s; }
  .joystick-base.dynamic { transition: none; }
  .joystick-knob { position: absolute; width: 56px; height: 56px; border-radius: 50%; background: rgba(255,255,255,0.3); border: 2px solid rgba(255,255,255,0.4); bottom: 62px; left: 62px; transform: translate(-50%,50%); transition: background 0.1s; pointer-events: none; }
  .joystick-knob.active { background: rgba(255,255,255,0.45); }
  .joystick-zone-right { position: absolute; bottom: 0; right: 0; width: 45%; height: 50%; pointer-events: auto; touch-action: none; }
  .mobile-btn { position: absolute; pointer-events: auto; touch-action: none; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-family: 'Fredoka', sans-serif; font-weight: 600; color: #fff; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); -webkit-tap-highlight-color: transparent; transition: transform 0.1s, background 0.1s; }
  .mobile-btn:active { transform: scale(0.9); }
  .btn-swing { bottom: 175px; right: 22px; width: 72px; height: 72px; background: rgba(232,130,42,0.65); border: 3px solid rgba(232,130,42,0.8); font-size: 1.8rem; }
  .btn-swing:active { background: rgba(232,130,42,0.9); }
  .btn-deposit { bottom: 175px; left: 22px; width: 64px; height: 64px; background: rgba(74,222,128,0.55); border: 3px solid rgba(74,222,128,0.7); font-size: 1.5rem; opacity: 0; transition: opacity 0.2s; pointer-events: none; }
  .btn-deposit.visible { opacity: 1; pointer-events: auto; }
  .btn-deposit:active { background: rgba(74,222,128,0.85); }

  #upgrade-screen { position: fixed; inset: 0; z-index: 200; background: rgba(20,15,10,0.92); display: none; flex-direction: column; align-items: center; justify-content: center; padding: 20px; overflow-y: auto; }
  #upgrade-screen.active { display: flex; }
  .upgrade-panel { background: #FFF5E6; border-radius: 20px; padding: 32px 40px; max-width: 600px; width: 100%; box-shadow: 0 10px 40px rgba(0,0,0,0.5); }
  @media (max-width: 600px) { .upgrade-panel { padding: 20px 18px; border-radius: 16px; } }
  .upgrade-title { font-family: 'Fredoka', sans-serif; font-size: 2.2rem; color: #4A3520; text-align: center; margin-bottom: 4px; }
  .upgrade-subtitle { text-align: center; color: #8B7355; font-size: 1rem; margin-bottom: 20px; }
  .upgrade-currency { text-align: center; font-family: 'Fredoka', sans-serif; font-size: 1.4rem; color: #E8822A; margin-bottom: 24px; }
  .upgrade-cards { display: flex; flex-direction: column; gap: 12px; margin-bottom: 24px; }
  .upgrade-card { display: flex; align-items: center; justify-content: space-between; background: #FFF; border-radius: 12px; padding: 14px 18px; border: 2px solid #E8DCC8; transition: border-color 0.2s; }
  .upgrade-card:hover { border-color: #E8822A; }
  .upgrade-card.disabled { opacity: 0.5; }
  .upgrade-info { flex: 1; }
  .upgrade-name { font-family: 'Fredoka', sans-serif; font-size: 1.1rem; color: #4A3520; display: flex; align-items: center; gap: 8px; }
  .upgrade-level { font-size: 0.8rem; color: #B8956A; }
  .upgrade-desc { font-size: 0.85rem; color: #8B7355; margin-top: 2px; }
  .upgrade-btn { background: #E8822A; color: #FFF; border: none; font-family: 'Fredoka', sans-serif; font-size: 1rem; padding: 8px 18px; border-radius: 8px; cursor: pointer; transition: background 0.2s; white-space: nowrap; }
  .upgrade-btn:hover { background: #D4730F; }
  .upgrade-btn.cant-afford { background: #C4B49A; cursor: default; }
  .start-day-btn { display: block; margin: 0 auto; background: #4ADE80; color: #1a4a2a; border: none; font-family: 'Fredoka', sans-serif; font-size: 1.3rem; padding: 14px 40px; border-radius: 50px; cursor: pointer; transition: background 0.2s, transform 0.1s; }
  .start-day-btn:hover { background: #34C96A; transform: scale(1.03); }
  .day-intro { position: fixed; top: 30%; left: 50%; transform: translate(-50%,-50%); font-family: 'Fredoka', sans-serif; font-size: 3rem; color: #F7C948; text-shadow: 3px 3px 6px rgba(0,0,0,0.6); z-index: 50; pointer-events: none; opacity: 0; display: none; }
  .day-intro.show { display: block; animation: dayIntro 2s ease-out forwards; }
  @keyframes dayIntro { 0%{opacity:0;transform:translate(-50%,-50%) scale(0.5);} 15%{opacity:1;transform:translate(-50%,-50%) scale(1.1);} 30%{opacity:1;transform:translate(-50%,-50%) scale(1);} 80%{opacity:1;} 100%{opacity:0;transform:translate(-50%,-60%) scale(1);} }
  @media (max-width: 600px) { .day-intro { font-size: 2.2rem; } .upgrade-title { font-size: 1.7rem; } }
</style>
</head>
<body>
<div id="blocker">
  <h1>üê± PURRSUIT</h1>
  <div class="subtitle" id="blocker-subtitle">Catch 'em all ‚Äî one day at a time</div>
  <div class="prompt" id="blocker-prompt">Click to Start</div>
  <div class="settings-panel" id="settings-panel">
    <div class="settings-title">‚öôÔ∏è Controls</div>
    <label class="setting-row"><span class="setting-label">Look Sensitivity</span><input type="range" id="setting-sensitivity" min="1" max="5" step="0.25" value="2.5"><span class="setting-value" id="sensitivity-value">2.5</span></label>
    <label class="setting-row"><span class="setting-label">Stick Dead Zone</span><input type="range" id="setting-deadzone" min="0.05" max="0.35" step="0.05" value="0.15"><span class="setting-value" id="deadzone-value">15%</span></label>
  </div>
</div>
<div id="hud">
  <div class="hud-top">
    <div><div class="hud-day">Day <span id="day-num">1</span></div><div class="hud-ring" id="hud-ring">Ring 1</div></div>
    <div class="hud-timer" id="timer">0:30</div>
    <div class="hud-score">Score: <span id="total-score">0</span></div>
    <div class="hud-pause" id="hud-pause">‚è∏</div>
  </div>
  <div class="crosshair"></div>
  <div class="hud-center-msg" id="center-msg"></div>
  <div class="catch-flash" id="catch-flash">Caught!</div>
  <div class="expand-flash" id="expand-flash"></div>
  <div class="hud-bottom-center"><div class="hud-bag" id="bag-display">üê± 0 / 1</div></div>
</div>
<div id="mobile-controls">
  <div class="joystick-zone" id="joystick-zone"><div class="joystick-base" id="joystick-base-left"></div><div class="joystick-knob" id="joystick-knob"></div></div>
  <div class="joystick-zone-right" id="joystick-zone-right"><div class="joystick-base" id="joystick-base-right" style="left:auto;right:20px;"></div><div class="joystick-knob" id="joystick-knob-right" style="left:auto;right:62px;"></div></div>
  <div class="mobile-btn btn-swing" id="btn-swing">ü•Ö</div>
  <div class="mobile-btn btn-deposit" id="btn-deposit">üì¶</div>
</div>
<div class="day-intro" id="day-intro"></div>
<div id="upgrade-screen">
  <div class="upgrade-panel">
    <div class="upgrade-title" id="upgrade-title">Day 1 Complete!</div>
    <div class="upgrade-subtitle" id="upgrade-stats"></div>
    <div class="upgrade-currency">üê± <span id="currency-display">0</span> cats to spend</div>
    <div class="upgrade-cards" id="upgrade-cards"></div>
    <button class="start-day-btn" id="start-day-btn">Start Next Day ‚Üí</button>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const isMobile = /Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
  || ('ontouchstart' in window && window.innerWidth < 1024);

// ===================== CONSTANTS =====================
const BASE_RING_RADIUS = 10;
const RING_EXPAND = 8;
const ROOM_HEIGHT = 5;
const DAY_DURATION = 30;
const CAT_COLORS = [0xE8822A,0x2A2A2A,0xF0EDE8,0x777777,0xD4956A,0xC4B49A,0x333333,0xC46A32,0x6B4226,0xAAAAAA];

// Ring visual themes
const RING_THEMES = [
  { floor1:'#C49A6C', floor2:'#B8895C', wall:0xE8DCC8, ceil:0xD4C9B8, trim:0x8B7355, pattern:'checker' },
  { floor1:'#7A9AB0', floor2:'#6B8BA2', wall:0xA8BCC8, ceil:0x98ACBA, trim:0x5A7A8B, pattern:'brick' },
  { floor1:'#7AAE6A', floor2:'#6A9E5A', wall:0xB0D4A0, ceil:0xA0C490, trim:0x4A7340, pattern:'diamond' },
  { floor1:'#B87272', floor2:'#A86262', wall:0xD4AAAA, ceil:0xC49A9A, trim:0x8B4444, pattern:'stripe' },
  { floor1:'#9878B4', floor2:'#8868A4', wall:0xC4B0D4, ceil:0xB4A0C4, trim:0x6B4A8B, pattern:'checker' },
  { floor1:'#C4A848', floor2:'#B49838', wall:0xD4C880, ceil:0xC4B870, trim:0x8B7820, pattern:'brick' },
  { floor1:'#5AAEA0', floor2:'#4A9E90', wall:0x90D4C8, ceil:0x80C4B8, trim:0x307868, pattern:'diamond' },
  { floor1:'#C0885C', floor2:'#B0784C', wall:0xD4BAA0, ceil:0xC4AA90, trim:0x8B6240, pattern:'stripe' },
];

function getTheme(ring) { return RING_THEMES[ring % RING_THEMES.length]; }
function ringInnerR(ring) { return ring === 0 ? 0 : BASE_RING_RADIUS + (ring - 1) * RING_EXPAND; }
function ringOuterR(ring) { return BASE_RING_RADIUS + ring * RING_EXPAND; }

// ===================== GAME STATE =====================
const state = {
  phase: 'MENU', day: 1, timeLeft: DAY_DURATION,
  dayScore: 0, totalScore: 0, currency: 0, catsInBag: 0,
  upgrades: { netSize: 0, walkSpeed: 0, bagSize: 0 },
  paused: false,
  settings: { lookSensitivity: 2.5, deadZone: 0.15 },
  // Permanent progression: which ring the player is currently trying to clear
  progressRing: 0,
  // Within a day, tracks if we expanded mid-day
  activeDayRing: 0,
  expanding: false,
};

function getCurrentMaxRadius() { return ringOuterR(state.activeDayRing); }
function getNetRange() { return 3.5 + state.upgrades.netSize * 1.0; }
function getNetAngle() { return 0.45 + state.upgrades.netSize * 0.1; }
function getMoveSpeed() { return 4.0 + state.upgrades.walkSpeed * 1.0; }
function getMaxBag() { return 1 + state.upgrades.bagSize; }
function getUpgradeCost(type) { const l = state.upgrades[type]; return (l + 1) * 2 + Math.floor(l * 0.5); }
function getCatCountForRing(ring) { return Math.min(8 * Math.pow(2, ring), 128); }
function getCatDifficulty(ring) { return 1 + ring * 0.35; }

// ===================== SOUND SYSTEM =====================
const soundAssets = { loaded: false, buffers: {} };
let audioCtx, bgMusic = null;
function getAudioCtx() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); return audioCtx; }

async function loadSoundManifest() {
  try {
    const r = await fetch('sounds/sounds.json'); if (!r.ok) throw 0;
    const manifest = await r.json();
    const ctx = getAudioCtx();
    for (const cat in manifest) soundAssets.buffers[cat] = [];
    await Promise.all(Object.entries(manifest).flatMap(([cat, paths]) =>
      paths.map(async p => {
        try { const r = await fetch(p); const ab = await r.arrayBuffer(); soundAssets.buffers[cat].push(await ctx.decodeAudioData(ab)); } catch(e){}
      })
    ));
    soundAssets.loaded = true;
  } catch(e) { soundAssets.loaded = false; }
}

function playAsset(cat, vol=1, rate=1) {
  if (!soundAssets.loaded || !soundAssets.buffers[cat]?.length) return false;
  try {
    const ctx = getAudioCtx(), buf = soundAssets.buffers[cat][Math.floor(Math.random()*soundAssets.buffers[cat].length)];
    const src = ctx.createBufferSource(), g = ctx.createGain();
    src.buffer = buf; src.playbackRate.value = rate; g.gain.value = vol;
    src.connect(g); g.connect(ctx.destination); src.start(); return true;
  } catch(e) { return false; }
}

function playPositionalAsset(cat, pos, maxVol=0.5, maxDist=15) {
  const d = camera.position.distanceTo(pos);
  return d < maxDist ? playAsset(cat, maxVol*(1-d/maxDist)) : false;
}

function startBgMusic() {
  if (!soundAssets.loaded || !soundAssets.buffers.music?.length || bgMusic) return;
  try { const ctx=getAudioCtx(); bgMusic=ctx.createBufferSource(); const g=ctx.createGain(); bgMusic.buffer=soundAssets.buffers.music[0]; bgMusic.loop=true; g.gain.value=0.3; bgMusic.connect(g); g.connect(ctx.destination); bgMusic.start(); } catch(e){}
}

// Synth fallbacks
function synthCat(pos,sz) {
  try { const ctx=getAudioCtx(),d=camera.position.distanceTo(pos); if(d>12) return; const v=0.08*(1-d/12),bp=(1.5-(sz||1)*0.5)*400,t=ctx.currentTime,o=ctx.createOscillator(),g=ctx.createGain(); o.connect(g);g.connect(ctx.destination);
  const tp=Math.random(); if(tp<0.5){o.frequency.setValueAtTime(bp*1.2,t);o.frequency.exponentialRampToValueAtTime(bp*0.8,t+0.15);o.frequency.exponentialRampToValueAtTime(bp*1.4,t+0.2);o.frequency.exponentialRampToValueAtTime(bp*0.5,t+0.4);g.gain.setValueAtTime(v,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.45);o.start(t);o.stop(t+0.45);} else if(tp<0.8){o.frequency.setValueAtTime(bp*1.5,t);o.frequency.exponentialRampToValueAtTime(bp*0.9,t+0.15);g.gain.setValueAtTime(v*0.7,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.2);o.start(t);o.stop(t+0.2);} else{o.type='sawtooth';o.frequency.setValueAtTime(bp*0.15,t);g.gain.setValueAtTime(v*0.3,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.6);o.start(t);o.stop(t+0.6);}
  } catch(e){} }
function synthCollect() { try { const ctx=getAudioCtx(),t=ctx.currentTime; [523,659,784,1047].forEach((f,i)=>{const o=ctx.createOscillator(),g=ctx.createGain();o.connect(g);g.connect(ctx.destination);o.frequency.setValueAtTime(f,t+i*0.07);g.gain.setValueAtTime(0.1,t+i*0.07);g.gain.exponentialRampToValueAtTime(0.001,t+i*0.07+0.2);o.start(t+i*0.07);o.stop(t+i*0.07+0.2);}); } catch(e){} }

function playCatSound(pos,sz) { const cats=['meow','screech','purring']; if(!playPositionalAsset(cats[Math.floor(Math.random()*3)],pos,0.4,15)) synthCat(pos,sz); }
function playCatchSound() { if(!playAsset('collect',0.5)) synthCollect(); }
function playDepositSound() { if(!playAsset('collect',0.6)) synthCollect(); }
function playWooshSound() { playAsset('woosh',0.4); }
function playTumblingSound() { playAsset('tumbling',0.6); }
function playUpgradeSound() { if(!playAsset('collect',0.5)) synthCollect(); }

// ===================== THREE.JS SETUP =====================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x2a1f14);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 200);
camera.position.set(0, 1.5, 0); scene.add(camera);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xFFF5E0, 0.4));
scene.add(new THREE.HemisphereLight(0xFFE8C0, 0x806040, 0.3));
const mainLight = new THREE.DirectionalLight(0xFFE0B0, 0.8);
mainLight.position.set(3, 8, 2); mainLight.castShadow = true;
mainLight.shadow.mapSize.set(1024,1024);
mainLight.shadow.camera.near=0.5; mainLight.shadow.camera.far=80;
mainLight.shadow.camera.left=-40; mainLight.shadow.camera.right=40;
mainLight.shadow.camera.top=40; mainLight.shadow.camera.bottom=-40;
scene.add(mainLight);

const pl1=new THREE.PointLight(0xFFAA44,0.5,25);pl1.position.set(5,3,3);scene.add(pl1);
const pl2=new THREE.PointLight(0xFFAA44,0.5,25);pl2.position.set(-4,3,-5);scene.add(pl2);

function updateFog() { const r=getCurrentMaxRadius(); scene.fog=new THREE.Fog(0x2a1f14, r*0.8, r*2.2); }

// ===================== RING ROOM SYSTEM =====================
// Each built ring stores its meshes so we can animate them independently
const builtRings = []; // { floor, wall, ceil, trim, outerR, ring }

function makeFloorTexture(theme) {
  const c = document.createElement('canvas'); c.width = c.height = 256;
  const ctx = c.getContext('2d');
  const ts = 32;
  if (theme.pattern === 'checker') {
    for (let x=0;x<256;x+=ts) for (let y=0;y<256;y+=ts) { ctx.fillStyle=((x/ts+y/ts)%2===0)?theme.floor1:theme.floor2; ctx.fillRect(x,y,ts,ts); }
  } else if (theme.pattern === 'brick') {
    ctx.fillStyle = theme.floor2; ctx.fillRect(0,0,256,256);
    ctx.fillStyle = theme.floor1;
    for (let row=0; row<8; row++) {
      const offset = (row%2) * (ts/2);
      for (let col=-1; col<9; col++) {
        ctx.fillRect(col*ts + offset + 1, row*ts + 1, ts-2, ts-2);
      }
    }
  } else if (theme.pattern === 'diamond') {
    ctx.fillStyle = theme.floor2; ctx.fillRect(0,0,256,256);
    ctx.fillStyle = theme.floor1;
    for (let x=0;x<256;x+=ts) for (let y=0;y<256;y+=ts) {
      ctx.save(); ctx.translate(x+ts/2,y+ts/2); ctx.rotate(Math.PI/4);
      ctx.fillRect(-ts/3,-ts/3,ts*2/3,ts*2/3); ctx.restore();
    }
  } else if (theme.pattern === 'stripe') {
    for (let y=0;y<256;y+=ts/2) { ctx.fillStyle=(Math.floor(y/(ts/2))%2===0)?theme.floor1:theme.floor2; ctx.fillRect(0,y,256,ts/2); }
  }
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  return tex;
}

function buildRingGeometry(ring) {
  const theme = getTheme(ring);
  const iR = ringInnerR(ring);
  const oR = ringOuterR(ring);
  const reps = Math.max(4, oR * 0.5);

  const tex = makeFloorTexture(theme);
  tex.repeat.set(reps, reps);

  // Floor: ring shape (circle for ring 0, annulus for others)
  let floorGeo;
  if (ring === 0) {
    floorGeo = new THREE.CircleGeometry(oR, 64);
  } else {
    floorGeo = new THREE.RingGeometry(iR, oR, 64);
  }
  const floor = new THREE.Mesh(floorGeo, new THREE.MeshStandardMaterial({ map: tex, roughness: 0.8, side: THREE.DoubleSide }));
  floor.rotation.x = -Math.PI/2; floor.receiveShadow = true;
  // Fix UVs for ring geometry to tile properly
  if (ring > 0) {
    const uvs = floor.geometry.attributes.uv;
    const pos = floor.geometry.attributes.position;
    for (let i=0; i<uvs.count; i++) {
      uvs.setXY(i, pos.getX(i)*0.5, pos.getY(i)*0.5);
    }
  }
  scene.add(floor);

  // Wall at outer edge
  const wall = new THREE.Mesh(
    new THREE.CylinderGeometry(oR, oR, ROOM_HEIGHT, 64, 1, true),
    new THREE.MeshStandardMaterial({ color: theme.wall, roughness: 0.9, side: THREE.BackSide })
  );
  wall.position.y = ROOM_HEIGHT/2; scene.add(wall);

  // Ceiling ring
  let ceilGeo;
  if (ring === 0) { ceilGeo = new THREE.CircleGeometry(oR, 64); }
  else { ceilGeo = new THREE.RingGeometry(iR, oR, 64); }
  const ceil = new THREE.Mesh(ceilGeo, new THREE.MeshStandardMaterial({ color: theme.ceil, roughness: 1, side: THREE.DoubleSide }));
  ceil.rotation.x = Math.PI/2; ceil.position.y = ROOM_HEIGHT; scene.add(ceil);

  // Trim
  const trim = new THREE.Mesh(
    new THREE.CylinderGeometry(oR-0.01, oR-0.01, 0.3, 64, 1, true),
    new THREE.MeshStandardMaterial({ color: theme.trim, side: THREE.BackSide })
  );
  trim.position.y = 0.15; scene.add(trim);

  const entry = { floor, wall, ceil, trim, outerR: oR, ring };
  builtRings.push(entry);
  return entry;
}

function clearAllRingMeshes() {
  for (const r of builtRings) {
    scene.remove(r.floor); scene.remove(r.wall); scene.remove(r.ceil); scene.remove(r.trim);
    if (r.fallingWall) scene.remove(r.fallingWall);
    if (r.fallingCeil) scene.remove(r.fallingCeil);
    if (r.fallingTrim) scene.remove(r.fallingTrim);
  }
  builtRings.length = 0;
}

function buildRoomUpToRing(maxRing) {
  clearAllRingMeshes();
  for (let i = 0; i <= maxRing; i++) buildRingGeometry(i);
  updateFog();
}

// ===================== WALL FALLING ANIMATION =====================
let expandAnim = null;
// Camera shake state
let camShakeIntensity = 0;
let camShakeTime = 0;

function startExpansion() {
  state.expanding = true;
  const currentRing = state.activeDayRing;
  const ringEntry = builtRings.find(r => r.ring === currentRing);
  if (!ringEntry) { state.expanding = false; return; }

  // The wall/ceil/trim of the current outermost ring will "fall"
  // We move them into a separate animation track
  const oR = ringEntry.outerR;
  const theme = getTheme(currentRing);

  // Create duplicate meshes for falling (the originals stay as the old boundary markers)
  // Actually, just animate the existing wall down, then remove it and build the next ring
  expandAnim = {
    wallMesh: ringEntry.wall,
    ceilMesh: ringEntry.ceil,
    trimMesh: ringEntry.trim,
    origWallY: ROOM_HEIGHT/2,
    origCeilY: ROOM_HEIGHT,
    origTrimY: 0.15,
    progress: 0,
    duration: 2.5,
    nextRing: currentRing + 1,
    cameraShakeDone: false,
  };

  camShakeIntensity = 0.12;
  camShakeTime = 0;

  const ef = document.getElementById('expand-flash');
  ef.textContent = `üåü Ring ${currentRing + 2} Unlocked! üåü`;
  ef.classList.remove('show'); void ef.offsetWidth; ef.classList.add('show');

  playTumblingSound();
}

function updateExpansion(dt) {
  if (!expandAnim) return;
  expandAnim.progress += dt / expandAnim.duration;

  // Camera shake (decays over time)
  camShakeTime += dt;
  if (camShakeTime < 1.8) {
    const decay = Math.max(0, 1 - camShakeTime / 1.8);
    camShakeIntensity = 0.12 * decay;
  } else {
    camShakeIntensity = 0;
  }

  const t = Math.min(expandAnim.progress, 1);

  // Wall falls: first tilts slightly, then drops
  const fallT = Math.min(t * 1.3, 1); // wall falls faster than full duration
  const eased = 1 - Math.pow(1 - fallT, 2); // ease-in (accelerating fall)

  // Wall drops below floor
  expandAnim.wallMesh.position.y = expandAnim.origWallY - eased * (ROOM_HEIGHT + 2);
  // Slight wobble rotation
  expandAnim.wallMesh.rotation.x = Math.sin(fallT * 8) * 0.02 * (1 - fallT);
  expandAnim.wallMesh.rotation.z = Math.sin(fallT * 6 + 1) * 0.015 * (1 - fallT);

  // Ceiling drops with slight delay
  const ceilT = Math.max(0, Math.min((t - 0.1) * 1.4, 1));
  const ceilEased = 1 - Math.pow(1 - ceilT, 2);
  expandAnim.ceilMesh.position.y = expandAnim.origCeilY - ceilEased * (ROOM_HEIGHT + 3);

  // Trim follows wall
  expandAnim.trimMesh.position.y = expandAnim.origTrimY - eased * 3;

  if (t >= 1) {
    // Remove old wall/ceil/trim
    scene.remove(expandAnim.wallMesh);
    scene.remove(expandAnim.ceilMesh);
    scene.remove(expandAnim.trimMesh);

    // Update state
    state.activeDayRing = expandAnim.nextRing;
    state.progressRing = Math.max(state.progressRing, state.activeDayRing);

    // Build the new ring geometry
    buildRingGeometry(state.activeDayRing);
    updateFog();
    updateRingDisplay();

    // Spawn cats for the new ring
    spawnCatsForRing(state.activeDayRing);

    camShakeIntensity = 0;
    state.expanding = false;
    expandAnim = null;
  }
}

// ===================== CRATE =====================
let crateMesh;
function createCrate() {
  const group = new THREE.Group();
  const box = new THREE.Mesh(new THREE.BoxGeometry(0.9,0.7,0.9), new THREE.MeshStandardMaterial({color:0x9B7340,roughness:0.8}));
  box.position.y = 0.35; box.castShadow = true; box.receiveShadow = true; group.add(box);
  const sm = new THREE.MeshBasicMaterial({color:0x7A5A2E});
  for (let i=-1;i<=1;i+=2) { const s=new THREE.Mesh(new THREE.BoxGeometry(0.92,0.04,0.03),sm); s.position.set(0,0.35+i*0.15,0.46); group.add(s); const s2=s.clone(); s2.position.z=-0.46; group.add(s2); }
  const ring = new THREE.Mesh(new THREE.RingGeometry(1.2,1.4,32), new THREE.MeshBasicMaterial({color:0xF7C948,transparent:true,opacity:0.3,side:THREE.DoubleSide}));
  ring.rotation.x = -Math.PI/2; ring.position.y = 0.01; group.add(ring);
  scene.add(group); crateMesh = group;
}

// ===================== CAT SYSTEM =====================
const cats = [];
function randomRange(a,b) { return a+Math.random()*(b-a); }

function createCatMesh(color, size) {
  const g = new THREE.Group(), m = new THREE.MeshStandardMaterial({color,roughness:0.7});
  const body = new THREE.Mesh(new THREE.SphereGeometry(0.22*size,8,6),m); body.scale.set(1,0.85,1.4); body.position.y=0.22*size; body.castShadow=true; g.add(body);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.16*size,8,6),m); head.position.set(0,0.32*size,0.28*size); head.castShadow=true; g.add(head);
  [-1,1].forEach(s=>{ const ear=new THREE.Mesh(new THREE.ConeGeometry(0.055*size,0.11*size,4),m); ear.position.set(s*0.08*size,0.46*size,0.26*size); g.add(ear); });
  const tail=new THREE.Mesh(new THREE.CylinderGeometry(0.025*size,0.015*size,0.35*size,5),m); tail.position.set(0,0.3*size,-0.3*size); tail.rotation.x=-0.6; g.add(tail);
  const eM=new THREE.MeshBasicMaterial({color:0xCCFF44}), pM=new THREE.MeshBasicMaterial({color:0x111111});
  [-1,1].forEach(s=>{ const eye=new THREE.Mesh(new THREE.SphereGeometry(0.03*size,6,4),eM);eye.position.set(s*0.06*size,0.35*size,0.42*size);g.add(eye); const pupil=new THREE.Mesh(new THREE.SphereGeometry(0.018*size,4,4),pM);pupil.position.set(s*0.06*size,0.35*size,0.445*size);g.add(pupil); });
  return g;
}

function spawnCatsForRing(ring) {
  const count = getCatCountForRing(ring);
  const diff = getCatDifficulty(ring);
  const iR = ring === 0 ? 4 : ringInnerR(ring) + 2;
  const oR = ringOuterR(ring) - 1.5;
  for (let i=0; i<count; i++) {
    const angle = Math.random()*Math.PI*2;
    const r = randomRange(iR, oR);
    const color = CAT_COLORS[Math.floor(Math.random()*CAT_COLORS.length)];
    const size = randomRange(0.7,1.3) * (1 + ring*0.15);
    const mesh = createCatMesh(color, size);
    mesh.position.set(Math.cos(angle)*r, 0, Math.sin(angle)*r);
    mesh.rotation.y = Math.random()*Math.PI*2;
    scene.add(mesh);
    cats.push({
      mesh, ring, size,
      speed: randomRange(1.0,2.5)*diff,
      turnSpeed: randomRange(1.5,4)*(1+ring*0.2),
      fleeDistance: randomRange(3.5,7)+ring*1,
      fleeStrength: Math.min(randomRange(0.4,0.95)+ring*0.1, 0.98),
      wanderAngle: Math.random()*Math.PI*2, wanderTimer: randomRange(0.5,3),
      velocity: new THREE.Vector3(), caught: false,
      soundTimer: randomRange(2,8), bobPhase: Math.random()*Math.PI*2,
      idleTimer: 0, isIdle: false,
    });
  }
}

function updateCat(cat, dt, playerPos) {
  if (cat.caught) return;
  const roomR = getCurrentMaxRadius() - 0.8;

  if (cat.isIdle) {
    cat.idleTimer -= dt; if (cat.idleTimer<=0) cat.isIdle=false;
    const d=new THREE.Vector3(cat.mesh.position.x,0,cat.mesh.position.z).distanceTo(playerPos);
    if (d<cat.fleeDistance*0.6) cat.isIdle=false;
    else { cat.velocity.multiplyScalar(0.9); cat.mesh.position.x+=cat.velocity.x*dt; cat.mesh.position.z+=cat.velocity.z*dt; clampToRoom(cat.mesh.position,roomR); return; }
  }

  cat.wanderTimer -= dt;
  if (cat.wanderTimer<=0) { cat.wanderAngle+=randomRange(-Math.PI*0.6,Math.PI*0.6); cat.wanderTimer=randomRange(1,4); if(Math.random()<0.25){cat.isIdle=true;cat.idleTimer=randomRange(0.5,2);} }

  const wD=new THREE.Vector3(Math.cos(cat.wanderAngle),0,Math.sin(cat.wanderAngle));
  const cP=new THREE.Vector3(cat.mesh.position.x,0,cat.mesh.position.z);
  const dP=cP.distanceTo(playerPos), fD=cP.clone().sub(playerPos).normalize();
  let fW = dP<cat.fleeDistance ? Math.pow(1-dP/cat.fleeDistance,0.8)*cat.fleeStrength : 0;
  const mD=wD.multiplyScalar(1-fW).add(fD.multiplyScalar(fW)); if(mD.length()>0.001) mD.normalize();
  cat.velocity.lerp(mD.multiplyScalar(cat.speed*(1+fW*0.5)), Math.min(cat.turnSpeed*dt,1));
  cat.mesh.position.x+=cat.velocity.x*dt; cat.mesh.position.z+=cat.velocity.z*dt;
  clampToRoom(cat.mesh.position, roomR);

  if (cat.velocity.length()>0.05) { const ta=Math.atan2(cat.velocity.x,cat.velocity.z); let d=ta-cat.mesh.rotation.y; while(d>Math.PI) d-=Math.PI*2; while(d<-Math.PI) d+=Math.PI*2; cat.mesh.rotation.y+=d*Math.min(cat.turnSpeed*dt*2,1); }
  cat.bobPhase+=dt*cat.speed*8; cat.mesh.position.y=cat.velocity.length()>0.2?Math.abs(Math.sin(cat.bobPhase))*0.04*cat.size:0;
  cat.soundTimer-=dt; if(cat.soundTimer<=0){playCatSound(cat.mesh.position,cat.size);cat.soundTimer=randomRange(4,14);}
}

function clampToRoom(pos, maxR) { const r=Math.sqrt(pos.x*pos.x+pos.z*pos.z); if(r>maxR){pos.x*=maxR/r;pos.z*=maxR/r;} }
function clearCats() { for(const c of cats) scene.remove(c.mesh); cats.length=0; }
function allCurrentCatsDone() { return cats.every(c=>c.caught) && state.catsInBag===0; }

// ===================== NET =====================
const netGroup = new THREE.Group();
let isSwinging=false, swingTime=0, canSwing=true, swingChecked=false;
const SWING_DURATION = 0.35;
function createNet() {
  const handle=new THREE.Mesh(new THREE.CylinderGeometry(0.018,0.014,0.7,6),new THREE.MeshStandardMaterial({color:0x8B5A2B}));handle.rotation.set(Math.PI/2.3,0,0);handle.position.set(0,-0.05,-0.25);netGroup.add(handle);
  const rim=new THREE.Mesh(new THREE.TorusGeometry(0.17,0.012,8,20),new THREE.MeshStandardMaterial({color:0x888888}));rim.position.set(0,0.12,-0.65);netGroup.add(rim);
  const nM=new THREE.MeshBasicMaterial({color:0xDDDDDD,transparent:true,opacity:0.35});
  for(let i=0;i<4;i++){const l=new THREE.Mesh(new THREE.CylinderGeometry(0.004,0.004,0.32,3),nM);l.rotation.z=(i/4)*Math.PI;l.position.set(0,0.12,-0.65);netGroup.add(l);}
  netGroup.position.set(isMobile?0.3:0.45, isMobile?-0.35:-0.4, 0);
  if(isMobile) netGroup.scale.set(1.15,1.15,1.15);
  camera.add(netGroup);
}
function startSwing() { if(!canSwing||isSwinging||state.phase!=='PLAYING'||state.expanding) return; isSwinging=true; swingTime=0; canSwing=false; swingChecked=false; playWooshSound(); }
function updateNet(dt) { if(!isSwinging) return; swingTime+=dt; const p=Math.min(swingTime/SWING_DURATION,1); netGroup.rotation.x=-Math.sin(p*Math.PI)*0.9; if(p>=0.35&&!swingChecked){checkCapture();swingChecked=true;} if(p>=1){isSwinging=false;netGroup.rotation.x=0;setTimeout(()=>{canSwing=true;},100);} }

// ===================== CAPTURE =====================
function checkCapture() {
  if(state.catsInBag>=getMaxBag()){showCenterMsg("Bag is full! Return to crate");return;}
  const fw=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);fw.y=0;if(fw.length()>0.001) fw.normalize();
  const pP=new THREE.Vector3(camera.position.x,0,camera.position.z);
  const range=getNetRange(),angle=getNetAngle();let closest=null,cD=Infinity;
  for(const cat of cats){if(cat.caught) continue;const tC=new THREE.Vector3(cat.mesh.position.x,0,cat.mesh.position.z).sub(pP);const d=tC.length();if(d>range) continue;if(d>0.01){tC.normalize();if(Math.acos(Math.min(fw.dot(tC),1))>angle) continue;}if(d<cD){cD=d;closest=cat;}}
  if(closest) catchCat(closest);
}
function catchCat(cat){cat.caught=true;scene.remove(cat.mesh);state.catsInBag++;showCatchFlash();playCatchSound();updateBagDisplay();}
function isNearCrate(){const dx=camera.position.x,dz=camera.position.z;return Math.sqrt(dx*dx+dz*dz)<2.0;}

function depositCats() {
  if(state.catsInBag===0) return;
  const count=state.catsInBag;
  state.dayScore+=count; state.totalScore+=count; state.currency+=count; state.catsInBag=0;
  showCenterMsg(`+${count} cat${count>1?'s':''} deposited!`);
  playDepositSound(); updateBagDisplay(); updateScoreDisplay();
  // Check if all cats cleared ‚Üí trigger expansion
  if(allCurrentCatsDone() && !state.expanding) {
    setTimeout(()=>startExpansion(), 600);
  }
}

// ===================== DESKTOP CONTROLS =====================
const keys={};let yaw=0,pitch=0,pointerLocked=false;
document.addEventListener('keydown',e=>{keys[e.code]=true;});
document.addEventListener('keyup',e=>{keys[e.code]=false;});
document.addEventListener('mousemove',e=>{if(!pointerLocked||isMobile)return;yaw-=e.movementX*0.002;pitch-=e.movementY*0.002;pitch=Math.max(-Math.PI/2.2,Math.min(Math.PI/2.2,pitch));});
document.addEventListener('mousedown',e=>{if(e.button===0&&pointerLocked&&state.phase==='PLAYING'&&!isMobile) startSwing();});
document.addEventListener('pointerlockchange',()=>{pointerLocked=document.pointerLockElement===renderer.domElement;if(!pointerLocked&&state.phase==='PLAYING'&&!isMobile){state.paused=true;document.getElementById('blocker').classList.remove('hidden');document.getElementById('blocker-prompt').textContent='Click to Resume';document.getElementById('blocker-subtitle').textContent='Game paused';}});
function requestPointerLock(){if(!isMobile) renderer.domElement.requestPointerLock();}

// ===================== MOBILE CONTROLS =====================
const mobileInput={moveX:0,moveY:0,lookX:0,lookY:0};
function setupMobileControls(){
  const btnSwing=document.getElementById('btn-swing'),btnDeposit=document.getElementById('btn-deposit'),hudPause=document.getElementById('hud-pause');
  function makeDJ(zId,bId,kId,onM,onE){
    const zone=document.getElementById(zId),base=document.getElementById(bId),knob=document.getElementById(kId);
    let tId=null,oX=0,oY=0;const jR=70,kR=28,maxR=jR-kR;
    zone.addEventListener('touchstart',e=>{e.preventDefault();if(tId!==null)return;const t=e.changedTouches[0];tId=t.identifier;oX=t.clientX;oY=t.clientY;
    base.style.cssText=`position:fixed;left:${oX-jR}px;top:${oY-jR}px;width:140px;height:140px;border-radius:50%;background:rgba(255,255,255,0.1);border:2px solid rgba(255,255,255,0.2);`;
    knob.style.cssText=`position:fixed;left:${oX}px;top:${oY}px;width:56px;height:56px;border-radius:50%;background:rgba(255,255,255,0.45);border:2px solid rgba(255,255,255,0.4);transform:translate(-50%,-50%);`;
    onM(0,0);},{passive:false});
    zone.addEventListener('touchmove',e=>{e.preventDefault();for(const t of e.changedTouches){if(t.identifier!==tId)continue;let dx=t.clientX-oX,dy=t.clientY-oY;const d=Math.sqrt(dx*dx+dy*dy);if(d>maxR){dx*=maxR/d;dy*=maxR/d;}
    knob.style.left=(oX+dx)+'px';knob.style.top=(oY+dy)+'px';
    const nx=dx/maxR,ny=dy/maxR,mag=Math.sqrt(nx*nx+ny*ny),dz=state.settings.deadZone;
    if(mag<dz)onM(0,0);else{const s=((mag-dz)/(1-dz))/mag;onM(nx*s,ny*s);}}},{passive:false});
    const end=e=>{for(const t of e.changedTouches){if(t.identifier!==tId)continue;tId=null;base.style.cssText='';knob.style.cssText='';onE();}};
    zone.addEventListener('touchend',end);zone.addEventListener('touchcancel',end);
  }
  makeDJ('joystick-zone','joystick-base-left','joystick-knob',(x,y)=>{mobileInput.moveX=x;mobileInput.moveY=y;},()=>{mobileInput.moveX=0;mobileInput.moveY=0;});
  makeDJ('joystick-zone-right','joystick-base-right','joystick-knob-right',(x,y)=>{mobileInput.lookX=x;mobileInput.lookY=y;},()=>{mobileInput.lookX=0;mobileInput.lookY=0;});
  btnSwing.addEventListener('touchstart',e=>{e.preventDefault();startSwing();},{passive:false});
  btnDeposit.addEventListener('touchstart',e=>{e.preventDefault();if(isNearCrate())depositCats();},{passive:false});
  hudPause.addEventListener('touchstart',e=>{e.preventDefault();e.stopPropagation();state.paused=true;document.getElementById('blocker').classList.remove('hidden');document.getElementById('blocker-prompt').textContent='Tap to Resume';document.getElementById('blocker-subtitle').textContent='Game paused';if(isMobile)document.getElementById('settings-panel').classList.add('visible');},{passive:false});
  const sS=document.getElementById('setting-sensitivity'),sV=document.getElementById('sensitivity-value'),dS=document.getElementById('setting-deadzone'),dV=document.getElementById('deadzone-value');
  sS.addEventListener('input',()=>{state.settings.lookSensitivity=parseFloat(sS.value);sV.textContent=sS.value;});
  dS.addEventListener('input',()=>{state.settings.deadZone=parseFloat(dS.value);dV.textContent=Math.round(dS.value*100)+'%';});
  document.getElementById('settings-panel').addEventListener('click',e=>e.stopPropagation());
  document.getElementById('settings-panel').addEventListener('touchend',e=>e.stopPropagation());
}

// ===================== PLAYER UPDATE =====================
let baseYaw = 0;
function updatePlayer(dt) {
  if(state.expanding) return;
  const speed=getMoveSpeed(),fw=new THREE.Vector3(-Math.sin(yaw),0,-Math.cos(yaw)),rt=new THREE.Vector3(Math.cos(yaw),0,-Math.sin(yaw)),mv=new THREE.Vector3();
  if(isMobile){
    if(Math.abs(mobileInput.moveX)>0.01||Math.abs(mobileInput.moveY)>0.01){mv.add(fw.clone().multiplyScalar(-mobileInput.moveY));mv.add(rt.clone().multiplyScalar(mobileInput.moveX));}
    const ls=state.settings.lookSensitivity;
    if(Math.abs(mobileInput.lookX)>0.01) yaw-=mobileInput.lookX*ls*dt;
    if(Math.abs(mobileInput.lookY)>0.01){pitch-=mobileInput.lookY*ls*dt;pitch=Math.max(-Math.PI/2.2,Math.min(Math.PI/2.2,pitch));}
  } else {
    if(keys['KeyW']||keys['ArrowUp']) mv.add(fw); if(keys['KeyS']||keys['ArrowDown']) mv.sub(fw);
    if(keys['KeyA']||keys['ArrowLeft']) mv.sub(rt); if(keys['KeyD']||keys['ArrowRight']) mv.add(rt);
  }
  if(mv.length()>0){mv.normalize().multiplyScalar(speed*dt);camera.position.x+=mv.x;camera.position.z+=mv.z;}
  clampToRoom(camera.position, getCurrentMaxRadius()-0.5);
  camera.position.y = 1.5;

  // Apply rotation + camera shake
  camera.rotation.order='YXZ';
  camera.rotation.y = yaw + (camShakeIntensity>0 ? (Math.random()-0.5)*camShakeIntensity : 0);
  camera.rotation.x = pitch + (camShakeIntensity>0 ? (Math.random()-0.5)*camShakeIntensity*0.5 : 0);

  if(!isMobile&&keys['KeyE']&&isNearCrate()) depositCats();
  if(isMobile) document.getElementById('btn-deposit').classList.toggle('visible',isNearCrate()&&state.catsInBag>0);
  const nc=isNearCrate();
  if(!isMobile){if(nc&&state.catsInBag>0) showCenterMsg("Press E to deposit"); else if(state.catsInBag>=getMaxBag()) showCenterMsg("Bag full! Return to crate"); else hideCenterMsg();}
  else{if(state.catsInBag>=getMaxBag()&&!nc) showCenterMsg("Bag full! Return to crate"); else hideCenterMsg();}
}

// ===================== UI =====================
function updateTimerDisplay(){const el=document.getElementById('timer'),s=Math.ceil(state.timeLeft);el.textContent=`${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`;el.classList.toggle('urgent',s<=10);}
function updateBagDisplay(){const el=document.getElementById('bag-display');el.textContent=`üê± ${state.catsInBag} / ${getMaxBag()}`;el.classList.toggle('full',state.catsInBag>=getMaxBag());}
function updateScoreDisplay(){document.getElementById('total-score').textContent=state.totalScore;}
function updateRingDisplay(){document.getElementById('hud-ring').textContent=`Ring ${state.activeDayRing+1} ¬∑ ${cats.filter(c=>!c.caught).length} left`;}
function showCenterMsg(t){const el=document.getElementById('center-msg');el.textContent=t;el.classList.add('visible');}
function hideCenterMsg(){document.getElementById('center-msg').classList.remove('visible');}
function showCatchFlash(){const el=document.getElementById('catch-flash');el.classList.remove('show');void el.offsetWidth;el.classList.add('show');}
function showDayIntro(){const el=document.getElementById('day-intro');el.textContent=`Day ${state.day}`;el.classList.remove('show');void el.offsetWidth;el.classList.add('show');}

// ===================== UPGRADES =====================
function showUpgradeScreen(){
  document.getElementById('upgrade-screen').classList.add('active');
  document.getElementById('upgrade-title').textContent=`Day ${state.day} Complete!`;
  document.getElementById('upgrade-stats').textContent=`You caught ${state.dayScore} cat${state.dayScore!==1?'s':''} today`;
  document.getElementById('currency-display').textContent=state.currency;
  renderUpgradeCards();
}
function renderUpgradeCards(){
  const c=document.getElementById('upgrade-cards');
  const ups=[
    {key:'netSize',name:'ü•Ö Net Size',desc:()=>`Range: ${getNetRange().toFixed(1)} ‚Üí ${(getNetRange()+1).toFixed(1)}`},
    {key:'walkSpeed',name:'üëü Walk Speed',desc:()=>`Speed: ${getMoveSpeed().toFixed(1)} ‚Üí ${(getMoveSpeed()+1).toFixed(1)}`},
    {key:'bagSize',name:'üéí Bag Size',desc:()=>`Capacity: ${getMaxBag()} ‚Üí ${getMaxBag()+1}`},
  ];
  c.innerHTML='';
  for(const up of ups){
    const cost=getUpgradeCost(up.key),can=state.currency>=cost;
    const card=document.createElement('div');card.className='upgrade-card'+(can?'':' disabled');
    card.innerHTML=`<div class="upgrade-info"><div class="upgrade-name">${up.name} <span class="upgrade-level">Lv ${state.upgrades[up.key]}</span></div><div class="upgrade-desc">${up.desc()}</div></div><button class="upgrade-btn ${can?'':'cant-afford'}">${cost} üê±</button>`;
    if(can) card.querySelector('.upgrade-btn').addEventListener('click',()=>{state.currency-=cost;state.upgrades[up.key]++;document.getElementById('currency-display').textContent=state.currency;playUpgradeSound();renderUpgradeCards();});
    c.appendChild(card);
  }
}
function hideUpgradeScreen(){document.getElementById('upgrade-screen').classList.remove('active');}

// ===================== GAME LOGIC =====================
function startDay(){
  state.phase='PLAYING'; state.paused=false;
  state.timeLeft=DAY_DURATION; state.dayScore=0; state.catsInBag=0;
  state.expanding=false; expandAnim=null; camShakeIntensity=0;

  // Start at the progress ring (permanent level)
  state.activeDayRing = state.progressRing;

  camera.position.set(0,1.5,0); yaw=0; pitch=0;

  clearCats();
  // Build all previously-cleared rings as scenery, plus the active one
  buildRoomUpToRing(state.activeDayRing);
  // Only spawn cats for the current progress ring
  spawnCatsForRing(state.activeDayRing);

  document.getElementById('hud').classList.add('active');
  if(isMobile) document.getElementById('mobile-controls').classList.add('active');
  document.getElementById('day-num').textContent=state.day;
  updateBagDisplay();updateScoreDisplay();updateTimerDisplay();updateRingDisplay();
  showDayIntro();hideCenterMsg();hideUpgradeScreen();
  if(!isMobile) requestPointerLock();
  startBgMusic();
}

function endDay(){
  state.phase='DAY_END';
  state.dayScore+=state.catsInBag;state.totalScore+=state.catsInBag;
  state.currency+=state.catsInBag;state.catsInBag=0;
  document.getElementById('hud').classList.remove('active');
  document.getElementById('mobile-controls').classList.remove('active');
  if(!isMobile) document.exitPointerLock();
  document.getElementById('blocker').classList.add('hidden');
  updateScoreDisplay();showUpgradeScreen();
}

document.getElementById('start-day-btn').addEventListener('click',()=>{state.day++;startDay();});

// ===================== BLOCKER =====================
function handleBlockerActivation(){
  if(state.phase==='MENU'){document.getElementById('blocker').classList.add('hidden');document.getElementById('settings-panel').classList.remove('visible');startDay();}
  else if(state.phase==='PLAYING'){state.paused=false;document.getElementById('settings-panel').classList.remove('visible');if(!isMobile)requestPointerLock();document.getElementById('blocker').classList.add('hidden');}
}
document.getElementById('blocker').addEventListener('click',handleBlockerActivation);
document.getElementById('blocker').addEventListener('touchend',e=>{e.preventDefault();handleBlockerActivation();});
if(isMobile){document.getElementById('blocker-prompt').textContent='Tap to Start';document.getElementById('settings-panel').classList.add('visible');}
renderer.domElement.addEventListener('touchstart',e=>e.preventDefault(),{passive:false});
renderer.domElement.addEventListener('touchmove',e=>e.preventDefault(),{passive:false});

// ===================== INIT & LOOP =====================
buildRoomUpToRing(0);
createCrate();
createNet();
if(isMobile) setupMobileControls();
loadSoundManifest();

let lastTime=0;
function gameLoop(time){
  requestAnimationFrame(gameLoop);
  const dt=Math.min((time-lastTime)/1000, 0.05);
  lastTime=time;

  const canUpdate=state.phase==='PLAYING'&&(isMobile||pointerLocked)&&!state.paused;
  if(canUpdate){
    if(expandAnim) updateExpansion(dt);
    if(!state.expanding){state.timeLeft-=dt;if(state.timeLeft<=0){state.timeLeft=0;endDay();} updateTimerDisplay();}
    updatePlayer(dt);
    const pp=new THREE.Vector3(camera.position.x,0,camera.position.z);
    for(const cat of cats) updateCat(cat,dt,pp);
    updateNet(dt);
    // Update ring display with remaining count
    if(!state.expanding) updateRingDisplay();
    if(crateMesh){const r=crateMesh.children[crateMesh.children.length-1];r.material.opacity=0.2+Math.sin(time*0.003)*0.1;}
  }
  renderer.render(scene,camera);
}
requestAnimationFrame(gameLoop);

window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);});
</script>
</body>
</html>
